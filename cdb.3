.\" cdb.3: cdb library manpage
.\"
.\" This file is based on the tinycdb package by Michael Tokarev, mjt@corpit.ru.
.\" Public domain.
.\"
.\" Patched for Chan FatFs by Torsten Raudssus, torsten@raudss.us.
.\"
.TH cdb 3 "Jun 2006"

.SH NAME
cdb \- Constant DataBase library

.SH SYNOPSYS

.nf
.ft B
 #include <cdb.h>

 UINT len = 0;
 FIL file;
 char buf[100];
 f_open(&file,"TEST.CDB",FA_READ);
 cdb_seek(&file,"ntpserver",9,&len);
 cdb_bread(&file,buf,len);
 buf[len] = '\0';
 printf("ntpserver: '%s'\r\n",buf);
.ft R
.fi

.SH DESCRIPTION

.B COPY OF ORIGINAL TINYCDB DOCUMENTATION

.B STILL WORK IN PROGRESS

.B cdb
is a library to create and access Constant DataBase files.
File stores (key,value) pairs and used to quickly find a
value based on a given key.  Cdb files are create-once files,
that is, once created, file cannot be updated but recreated
from scratch -- this is why database is called \fIconstant\fR.
Cdb file is optimized for quick access.  Format of such file
described in \fIcdb\fR(5) manpage.  This manual page corresponds
to version \fB0.78\fR of \fBtinycdb\fR package.

Library defines two non-interlaced interfaces: for querying
existing cdb file data (read-only mode) and for creating
such a file (almost write-only).  Strictly speaking, those
modes allows very limited set of opposite operation as well
(i.e. in query mode, it is possible to update key's value).

All routines in this library are thread-safe as no global
data used, except of \fIerrno\fR variable for error indication.

The \fIfd\fR filedescriptor in this documentation references to
the \fBFile object structure\fR (FIL) in ChanFs.

.B cdb
datafiles may be moved between systems safely, since format
does not depend on architecture.

.SH "QUERY MODE"

.nf
unsigned \fBcdb_unpack\fR(\fIbuf\fR)
   const unsigned char \fIbuf\fR[4];
.fi
.RS
helper routine to convert 32-bit integer from internal representation
to machine format.  May be used to handle application integers in
a portable way.  There is no error return.
.RE

.SS "Query Mode 2 (only usable with microcontroller and FatFs)"

In this mode, one need to open a \fBcdb\fR file using one of
standard system calls (such as \fBopen\fR(2)) to obtain a
filedescriptor, and then pass that filedescriptor to cdb routines.
Available methods to query a cdb database using only a filedescriptor
include:

.nf
int \fBcdb_seek\fR(\fIfd\fR, \fIkey\fR, \fIklen\fR, \fIdlenp\fR)
  FIL *\fIfd\fR;
  const void *\fIkey\fR;
  unsigned \fIklen\fR;
  unsigned *\fIdlenp\fR;
.fi
.RS
searches a cdb database (as pointed to by \fIfd\fR filedescriptor)
for a key given by (\fIkey\fR, \fIklen\fR), and positions file pointer
to start of data associated with that key if found, so that next read
operation from this filedescriptor will read that value, and places
length of value, in bytes, to variable pointed to by \fIdlenp\fR.
Returns positive value if operation was successful, 0 if key was not
found, or negative value on error.  To read the data from a cdb file,
\fBcdb_bread\fR() routine below can be used.
.RE

.nf
int \fBcdb_bread\fR(\fIfd\fR, \fIbuf\fR, \fIlen\fR)
  FIL *\fIfd\fR;
  void *\fIbuf\fR;
  int \fIlen\fR;
.fi
.RS
reads data from a file (as pointed to by \fIfd\fR filedescriptor) and
places \fIlen\fR bytes from this file to a buffer pointed to by \fIbuf\fR.
Returns 0 if exactly \fIlen\fR bytes was read, or a negative value in
case of error or end-of-file.  This routine ignores interrupt errors (EINTR).
Sets errno variable to \fBEIO\fR in case of end-of-file condition (when
there is less than \fIlen\fR bytes available to read).
.RE

.SS Notes

Note that \fIvalue\fR of any given key may be updated in place
by another value of the same size, by writing to file at position
found by \fBcdb_find\fR() or \fBcdb_seek\fR().  However one should
be very careful when doing so, since write operation may not succeed
in case of e.g. power failure, thus leaving corrupted data.  When
database is (re)created, one can guarantee that no incorrect data
will be written to database, but not with inplace update.  Note
also that it is not possible to update any key or to change length
of value.

.SS

.SH "CREATING MODE"

.B cdb
database file should usually be created in two steps: first, temporary
file created and written to disk, and second, that temporary file
is renamed to permanent place.  Unix rename(2) call is atomic operation,
it removes destination file if any AND renaes another file in one
step.  This way it is guaranteed that readers will not see incomplete
database.  To prevent multiple simultaneous updates, locking may
also be used.

All routines used to create \fBcdb\fR database works with
\fBstruct cdb_make\fR object that is opaque to application.
Application may assume that \fBstruct cdb_make\fR has at least
the same member(s) as published in \fBstruct cdb\fR above.

.nf
int \fBcdb_make_start\fR(\fIcdbmp\fR, \fIfd\fR)
   struct cdb_make *\fIcdbmp\fR;
   FIL *\fIfd\fR;
.fi
.RS
initializes structure to create a database.  File \fIfd\fR should be
opened read-write and should be seekable.  Returns 0 on success
or negative value on error.
.RE

.nf
int \fBcdb_make_add\fR(\fIcdbmp\fR, \fIkey\fR, \fIklen\fR, \fIval\fR, \fIvlen\fR)
   struct cdb_make *\fIcdbmp\fR;
   const void *\fIkey\fR, *\fIval\fR;
   unsigned \fIklen\fR, \fIvlen\fR;
.fi
.RS
adds record with key (\fIkey\fR,\fIklen\fR) and value (\fIval\fR,\fIvlen\fR)
to a database.  Returns 0 on success or negative value on error.  Note that
this routine does not checks if given key already exists, but \fBcdb_find\fR()
will not see second record with the same key.  It is not possible to continue
building a database if \fBcdb_make_add\fR() returned error indicator.
.RE

.nf
int \fBcdb_make_finish\fR(\fIcdbmp\fR)
   struct cdb_make *\fIcdbmp\fR;
.fi
.RS
finalizes database file, constructing all needed indexes, and frees
memory structures.  It does \fInot\fR closes filedescriptor.
Returns 0 on success or negative value on error.
.RE

.nf
int \fBcdb_make_exists\fR(\fIcdbmp\fR, \fIkey\fR, \fIklen\fR)
   struct cdb_make *\fIcdbmp\fR;
   const void *\fIkey\fR;
   unsigned \fIklen\fR;
.fi
.RS
This routine attempts to find given by (\fIkey\fR,\fIklen\fR) key in
a not-yet-complete database.  It may significantly slow down the
whole process, and currently it flushes internal buffer to disk on
every call with key those hash value already exists in db.  Returns
0 if such key doesn't exists, 1 if it is, or negative value on error.
Note that database file should be opened read-write (not write-only)
to use this routine.  If \fBcdb_make_exists\fR() returned error, it
may be not possible to continue constructing database.
.RE

.nf
int \fBcdb_make_find\fR(\fIcdbmp\fR, \fIkey\fR, \fIklen\fR, \fImode\fR)
   struct cdb_make *\fIcdbmp\fR;
   const void *\fIkey\fR;
   unsigned \fIklen\fR;
   int \fImode\fR;
.fi
.RS
This routine attempts to find given by (\fIkey\fR,\fIklen\fR) key in
the database being created.  If the given key is already exists, it
an action specified by \fImode\fR will be performed:
.IP \fBCDB_FIND\fR
checks whenever the given record is already in the database.
.IP \fBCDB_FIND_REMOVE\fR
removes all matching records by re-writing the database file accordingly.
.IP \fBCDB_FIND_FILL0\fR
fills all matching records with zeros and removes them from index so that
the records in question will not be findable with \fBcdb_find\fR().  This
is faster than CDB_FIND_REMOVE, but leaves zero "gaps" in the database.
Lastly inserted records, if matched, are always removed.
.PP
If no matching keys was found, routine returns 0.  In case at least one
record has been found/removed, positive value will be returned.  On
error, negative value will be returned and \fBerrno\fR will be set
appropriately.  When \fBcdb_make_find\fR() returned negative value in
case of error, it is not possible to continue constructing the database.
.PP
\fBcdb_make_exists\fR() is the same as calling \fBcdb_make_find\fR() with
\fImode\fR set to CDB_FIND.
.RE

.nf
int \fBcdb_make_put\fR(\fIcdbmp\fR, \fIkey\fR, \fIklen\fR, \fIval\fR, \fIvlen\fR, \fImode\fR)
   struct cdb_make *\fIcdbmp\fR;
   const void *\fIkey\fR, *\fIval\fR;
   unsigned \fIklen\fR, \fIvlen\fR;
   int \fImode\fR;
.fi
.RS
This is a somewhat combined \fBcdb_make_exists\fR() and
\fBcdb_make_add\fR() routines.  \fImode\fR argument controls how
repeated (already existing) keys will be treated:
.IP \fBCDB_PUT_ADD\fR
no duplicate checking will be performed.  This mode is the same as
\fBcdb_make_add\fR() routine does.
.IP \fBCDB_PUT_REPLACE\fR
If the key already exists, it will be removed from the database
before adding new key,value pair.  This requires moving data in
the file, and can be quite slow if the file is large.
All matching old records will be removed this way.  This is the
same as calling \fBcdb_make_find\fR() with CDB_FIND_REMOVE
\fImode\fR argument followed by calling \fBcdb_make_add\fR().
.IP \fBCDB_PUT_REPLACE0\fR
If the key already exists and it isn't the last record in the file,
old record will be zeroed out before adding new key,value pair.
This is alot faster than CDB_PUT_REPLACE, but some extra data will
still be present in the file.  The data -- old record -- will not
be accessible by normal searches, but will appear in sequential
database traversal.  This is the same as calling \fBcdb_make_find\fR()
with CDB_FIND_FILL0 \fImode\fR argument followed by \fBcdb_make_add\fR().
.IP \fBCDB_PUT_INSERT\fR
add key,value pair only if such key does not exists in a database.
Note that since query (see query mode above) will find first added
record, this mode is somewhat useless (but allows to reduce database
size in case of repeated keys).  This is the same as calling
\fBcdb_make_exists\fR(), followed by \fBcdb_make_add\fR() if
the key was not found.
.IP \fBCDB_PUT_WARN\fR
add key,value pair unconditionally, but also check if this key
already exists.  This is equivalent of \fBcdb_make_exists\fR()
to check existence of the given key, unconditionally followed
by \fBcdb_make_add\fR().
.PP
If any error occurred during operations, the routine will return
negative integer and will set global variable \fBerrno\fR to
indicate reason of failure.  In case of successful operation
and no duplicates found, routine will return 0.  If any duplicates
has been found or removed (which, in case of CDB_PUT_INSERT mode,
indicates that the new record was not added), routine will return
positive value.  If an error occurred and \fBcdb_make_put\fR() returned
negative error, it is not possible to continue database construction
process.
.PP
As with \fBcdb_make_exists\fR() and \fBcdb_make_find\fR(), usage
of this routine with any but CDB_PUT_ADD mode can significantly
slow down database creation process, especially when \fImode\fR
is equal to CDB_PUT_REPLACE0.

.RE
.nf
void \fBcdb_pack\fR(\fInum\fR, \fIbuf\fR)
   unsigned \fInum\fR;
   unsigned char \fIbuf\fR[4];
.fi
.RS
helper routine that used internally to convert machine integer \fIn\fR
to internal form to be stored in datafile.  32-bit integer is stored in
4 bytes in network byte order.  May be used to handle application data.
There is no error return.
.RE

.nf
unsigned \fBcdb_hash\fR(\fIbuf\fR, \fIlen\fR)
   const void *\fIbuf\fR;
   unsigned \fIlen\fR;
.fi
.RS
helper routine that calculates cdb hash value of given bytes.
CDB hash function is
.br
  hash[n] = (hash[n\-1] + (hash[n\-1] << 5)) ^ buf[n]
.br
starting with
.br
  hash[\-1] = 5381
.br
.RE

.SH ERRORS

.B cdb
library may set \fBerrno\fR to following on error:

.IP EPROTO
database file is corrupted in some way
.IP EINVAL
the same as EPROTO above if system lacks EPROTO constant
.IP EINVAL
\fIflag\fR argument for \fBcdb_make_put\fR() is invalid
.IP EEXIST
\fIflag\fR argument for \fBcdb_make_put\fR() is CDB_PUT_INSERT,
and key already exists
.IP ENOMEM
not enough memory to complete operation (\fBcdb_make_finish\fR and
\fBcdb_make_add\fR)
.IP EIO
set by \fBcdb_bread\fR and \fBcdb_seek\fR if a cdb file is shorter
than expected or corrupted in some other way.

.SH EXAMPLES

.PP
Note: in all examples below, error checking is not shown for brewity.

.SS "Query Mode"

.nf
 FIL file;
 f_open(&file, filename, FA_READ);
 if (cdb_seek(&file, key, keylen, &datalen) > 0) {
   data = malloc(datalen + 1);
   cdb_bread(fd, data, datalen);
   data[datalen] = '\\0';
   printf("key=%s data=%s\\n", key, data);
 }
 else
   printf("key=%s not found\\n", key);
 close(fd);
.fi

.SS "Create Mode"

.nf
 FIL *fd;
 FRESULT fr;
 struct cdb_make cdbm;
 char *key, *data;
 unsigned keylen, datalen;

 /* initialize the database */
 fr = f_open(fd, "NEW.CDB", FA_READ|FA_WRITE|FA_CREATE_ALWAYS);
 if (fr) return -1; // error on opening
 cdb_make_start(&cdbm, fd);

 while(have_more_data()) {
   /* initialize key and data */
   if (cdb_make_exists(&cdbm, key, keylen) == 0)
     cdb_make_add(&cdbm, key, keylen, data, datalen);
   /* or use cdb_make_put() with appropriate flags */
 }

 /* finalize and close the database */
 cdb_make_finish(&cdbm);
 f_close(fd);
.fi

.SH "SEE ALSO"
cdb(5), cdb(1), dbm(3), db(3), open(2).

.SH AUTHOR
The \fBtinycdb\fR package written by Michael Tokarev <mjt@corpit.ru>,
based on ideas and shares file format with original cdb library by
Dan Bernstein.

.SH LICENSE
Public domain.
